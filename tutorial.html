<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Tutorial</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/main.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>

      <header>
        <h1>Tutorial</h1>
        <p>A tutorial introduction to jPregel-aws</p>
      </header>

      <div id="banner">
        <span id="logo"></span>

        <a href="https://github.com/charlesmunger/jpregel-aws" class="button fork"><strong>View On GitHub</strong></a>
        <div class="downloads">
          <span>Download:</span>
          <ul>
            <!--<li><a href="https://github.com/charlesmunger/jpregel-aws/zipball/master" class="button">ZIP</a></li> -->
            <li><a href="https://github.com/charlesmunger/jpregel-aws/tarball/master" class="button">JAR</a></li>
          </ul>
        </div>
      </div><!-- end banner -->

    <div class="wrapper">
      <nav>
        <ul>
	        <li><a href="index.html">Home</a></li>
        	<li><a href="javadoc-api/index.html" target="parent">API</a></li>
			<li><a href="tutorial.html">Tutorial</a></li>
        </ul>
      </nav>
      <section>
	
	<h1>Tutorial</h1>
	
	<h3>Make magic with jPregel-aws!</h3>
	
	<p><img src="images/merlin.gif" alt="merlin with student" width="400" /></p>
	
	<h2>Table of Contents</h2>
	
	<ol>
		<li><a href="#Introduction-to-jpregel">Introduction to jPregel</a></li>
		<li>
			<a href="#Developing-jpregel-Applications">Developing jPregel Applications</a>
			<ol>
				<li>
					Birds eye tour of a jPregel client
					<ol>
						<li>What's in a Job?</li>
						<li>The Job directory structure</li>
						<li>Selecting Master &amp; Worker graph makers</li>
						<li>Selecting a Vertex class</li>
						<li>Selecting Master &amp; Worker output makers</li>
						<li>Running a Job</li>
					</ol>
				</li>
				<li><a href="#Defining-a-Vertex-class">Defining a Vertex class: Encapsulating a distributed graph algorithm</a></li>
				<li>
					The Vertex API
					<ol>
						<li>A tutorial of Vertex methods goes here</li>
					</ol>
				</li>
				<li>Making a Master Graph Maker</li>
				<li>Making a Worker Graph Maker</li>
				<li>Making a Master Output Maker</li>
				<li>Making a Worker Output Maker</li>
			</ol>
		</li>
		<li>
			<a href="#Deploying-jpregel-Applications">Deploying jPregel Applications</a>
			<ol>
				<li>On 1 machine</li>
				<li>On a Local Area Network (LAN)</li>
				<li>
					On Amazon Web Services (AWS)
					<ol>
						<li>Initial set up</li>
						<li>Deploying</li>
					</ol>
				</li>
			</ol>
		</li>
		<li>
			<a href="#Contributing-to-the-jpregel-project">Contributing to the jPregel project</a>
		</li>
	</ol>
	<hr>
	
	<a name="Introduction-to-jpregel"><h2>Introduction to jPregel</h2></a>
	
	<p>jpregel is based on the paper 
		<a href="http://dl.acm.org/citation.cfm?id=1582723">"Pregel: a system for large-scale graph processing."</a>
		<!--
			by Grzegorz Malewicz, Matthew H. Austern, Aart J.C. Bik, James C. Dehnert, Ilan Horn, Naty Leiser, and 	Grzegorz Czajkowski 
			(all affiliated with Google, Inc.),
		Proceedings, PODC Proceedings of the 28th ACM symposium on Principles of Distributed Computing, 2009.
		-->
		</p>
		<p>
		jPregel's computational model consists of a set of directed graph (digraph) and may be described as vertex-centric.
		Every vertex in the graph is associated with the same <i>vertex algorithm</i>, encapsulated in its <i>compute</i> method.
		Attributes associated with each vertex include:
		<ol>
			<li>a unique vertex identifier</li>
			<li>a value</li>
			<li>a collection of out-edges, each of which has an associated value.</li>
		</ol>
		A <i>digraph algorithm</i> consists of a sequence of steps.
		Associated with each step is a set of <i>active vertices</i>.
		The initial set of active vertices is determined by the graph construction process.
		In subsequent steps, a vertex is active if and only if the set of messages sent to it in the previous step is non-empty.
		At each step, each active vertex invokes its compute method, which may:
		<ul>
			<li>read messages sent to the vertex from vertices during the previous step;</li>
			<li>modify its state</li>
			<li>send messages to vertices, (including itself) to be received by them during the next step.</li>
		</ul> 
		If a step has an empty set of active vertices, the digraph algorithm halts.
		(This method for detecting termination of the digraph algorithm is different, but equivalent, to that of Pregel.)
		The following simple example gives the flavor of these concepts.
	</p>
	
	<h4>Example 1.1: Detecting a digraph's source nodes</h4>
	<p>
		At the time a digraph is constructed, a vertex, <i>v</i>, does not "know" if it has in-edges 
		(i.e., <i>v</i> does not "know" if there is a vertex <i>u</i> with an out-edge to <i>v</i>).
		Let us define a jpregel algorithm to determine if a vertex is a source (i.e., has no in-edges).
		We will illustrate our algorithm on the small digraph below:
	
		<center><img src="images/figures/source-graph-input.png" alt="a simple 7 node digraph with 2 source nodes." width="400"></center>
	</p>
	<p>
		Here is a simple algorithm to do this: 
		When the graph is constructed, all vertices are put in the active set and all vertices are initialized as a source.
		During the initial step of the graph algorithm, each vertex <i>u</i> sends a message (whose content is irrelevant) to vertex <i>v</i>, 
		if (<i>u</i>, <i>v</i>) is an out-edge of <i>u</i>.
		During the next step, active vertices mark themselves as not being a source.
		No messages are sent during this second step:
		The algorithm thus terminates after 2 steps.
		</p>
		<p>
		Regarding the correctness of the algorithm,
		after the graph algorithm terminates, 
		<i>vertex <i>v</i> is marked as not being a source</i> 
		if and only if <i>v</i> had at least one message at step 2
		if and only if there is a vertex <i>u</i> with out-edge (<i>u</i>, <i>v</i>) in step 1
		if and only if <i>v</i> has in-edge (<i>u</i>, <i>v</i>)
		if and only if <i><i>v</i> is not a source</i>.
		</p>
		<p>
			After the graph computation terminates, there is an <i>output phase</i>.
			During the output phase of our source identification problem, each vertex outputs true, if it is a source, and false otherwise. 
		</p>
		<p>
		The following code fragment makes these ideas more precise, where the value associated with the vertex is a Boolean, 
		which, after the graph algorithm terminates, has a value of true if and only if the vertex is a source.
	</p>
	<style>
	<!--
	body {color: #000000; background-color: #ffffff; font-family: Monospaced}
	pre {color: #000000; background-color: #ffffff; font-family: Monospaced}
	table {color: #000000; background-color: #e9e8e2; font-family: Monospaced}
	.ST2 {font-family: Monospaced; font-style: italic}
	.ST1 {font-family: Monospaced; font-weight: bold}
	.ST0 {color: #969696; font-family: Monospaced; font-weight: bold}
	.comment {color: #969696}
	.character {color: #ce7b00}
	.keyword-directive {color: #0000e6}
	-->
	</style>
	
	<pre>
	    @Override
	    <span class="keyword-directive">public</span> <span class="keyword-directive">void</span> <span class="ST1">compute</span>() 
	    {
	        <span class="keyword-directive">if</span> ( <span class="keyword-directive">null</span> == getVertexValue() ) {
	            setVertexValue( <span class="keyword-directive">true</span> ); <span class="comment">// initially mark all vertices as sources</span>

	            <span class="comment">// for each out-edge (u, v), send a message to vertex v</span>
	            <span class="keyword-directive">for</span> ( Integer targetVertexId : getEdgeTargets() ) {
	                sendMessage( targetVertexId, <span class="keyword-directive">new</span> Message( <span class="keyword-directive">null</span>, <span class="keyword-directive">null</span> ) );
	            }
	        }
	        <span class="keyword-directive">else</span> <span class="keyword-directive">if</span> ( getMessageQ().size() &gt; 0 ) {
	                setVertexValue( <span class="keyword-directive">false</span> ); <span class="comment">// I have at least 1 in-edge!</span>
	        }
	    }

	    @Override
	    <span class="keyword-directive">public</span> String <span class="ST1">output</span>() { <span class="keyword-directive">return</span> getVertexId() + <span class="character">&quot;</span> <span class="character">&quot;</span> + getVertexValue(); }
	</pre>
	<p>
		Using the output from this jPregel application, if one were to paint the source vertices red and the non-source vertices blue, our small graph would, of course, look as follows:
		<center><img src="images/figures/source-graph-output.png" alt="a simple 7 node digraph with 2 source nodes." width="400"></center>
	</p>
	
	<a name="Developing-jpregel-Applications"><h2>Developing jPregel Applications</h2></a>
	
	<p>A jPregel <i>job</i> proceeds in 3 phases:
		<ol>
			<li>Construct a digraph;</li>
			<li>Execute its algorithm;</li>
			<li>Produce its output.</li>
		</ol>
	</p>
	
	<a name="Defining-a-Vertex-class"><h3>Defining a Vertex class: Encapsulating a distributed graph algorithm</h3></a>
	
	<p>
		A Vertex class directly or indirectly extends <i>VertexImpl</i>, which implements the <i>Vertex</i> interface.
		To be continued ...
	</p>
	
	
	<ol>
	</ol>
	
	<a name="Deploying-Applications"><h2>Deploying jPregel Applications</h2></a>
	<!--
	<h3>Deploying on a single machine</h3>
	
	<h3>Deploying on a local cluster</h3>
	
	<h3>Deploying on Amazon Web Services</h3>
	
	<ol>
		<li>Deploying with AWS
			<ol>
				<li>Setting up to deploy
					<ol>
						<li>Create an Amazon Web Services account. This requires a credit card.</li>
						<li>Create two SSH key pairs, named "privatekey" and "masterkey".</li>
						<li>Save these into privatekey.pem and masterkey.pem, in the jpregel-aws directory.</li>
						<li>Create a file named key.AWSkey, with your access key on the first line and your secret key on the second.</li>
					</ol>
				</li>
				<li>Deploying
					<ol>
						<li>From a Nebeans confirguration
							<ol>
								<li>
									<p>Specify a Main file with ant:</p>
									<p>ant run -propertyfile nbproject/configs/ShortestPath.properties -Dapplication.args="foobucket 10 10"</p>
								</li>
							</ol>
					</ol>
				</li>
			</ol>
		</li>
	</ol>
	-->
	
	<a name="Contributing-to-the-jpregel-project"><h2>Contributing to jPregel</h2></a>
	
      </section>
      <footer>
        <p>Project maintained by <a href="https://github.com/charlesmunger">charlesmunger</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="http://twitter.com/#!/michigangraham">mattgraham</a></small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>