<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Tutorial</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/main.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>

      <header>
        <h1>Tutorial</h1>
        <p>An introduction to jPregel-aws</p>
      </header>

      <div id="banner">
        <span id="logo"></span>

        <a href="https://github.com/charlesmunger/jpregel-aws" class="button fork"><strong>View On GitHub</strong></a>
<!--
        <div class="downloads">
          <span>Download:</span>
          <ul>
            <li><a href="https://github.com/charlesmunger/jpregel-aws/zipball/master" class="button">ZIP</a></li> 

            <li><a href="https://github.com/charlesmunger/jpregel-aws/tarball/master" class="button">JAR</a></li>
          </ul>
        </div>
-->
      </div><!-- end banner -->

    <div class="wrapper">
      <nav>
        <ul>
	        <li><a href="index.html"><img src="images/Home24.gif" /></a></li>
        	<li><a href="javadoc-api/index.html" target="parent">API</a></li>
			<li><a href="tutorial.html">Tutorial</a></li>
        </ul>
      </nav>
      <section>
	
	<h1>Tutorial</h1>
	
	<h3>Make magic with jPregel-aws!</h3>
	
	<p><img src="images/merlin.gif" alt="merlin with student" width="400" /></p>
	
	<h2>Table of Contents</h2>
	
	<ol>
		<li><a href="#Introduction-to-jpregel">Introduction to jPregel</a></li>
		<li>
			<a href="developing-applications.html">Developing Applications</a>
			<!--
			<ol>
				<li>
					Birds eye tour of a jPregel client
					<ol>
						<li>What's in a Job?</li>
						<li>The Job directory structure</li>
						<li>Selecting Master &amp; Worker graph makers</li>
						<li>Selecting a Vertex class</li>
						<li>Selecting Master &amp; Worker output makers</li>
						<li>Running a Job</li>
					</ol>
				</li>
				<li>Defining a Vertex class: Encapsulating a distributed graph algorithm</li>
				<li>
					The Vertex API
					<ol>
						<li>A tutorial of Vertex methods goes here</li>
					</ol>
				</li>
				<li>Making a Master Graph Maker</li>
				<li>Making a Worker Graph Maker</li>
				<li>Making a Master Output Maker</li>
				<li>Making a Worker Output Maker</li>
			</ol>
		-->
		</li>
	
		<li>
			<a href="deploying-applications.html">Deploying Applications</a>
			<!--
			<ol>
				<li>On 1 machine</li>
				<li>On a Local Area Network (LAN)</li>
				<li>
					On Amazon Web Services (AWS)
					<ol>
						<li>Initial set up</li>
						<li>Deploying</li>
					</ol>
				</li>
			</ol>
		-->
		</li>
		<li>
			<a href="contributing-to-jpregel.html">Contributing to jPregel</a>
		</li>
	</ol>
	<hr>
	
	<a name="Introduction-to-jpregel"><h2>Introduction to jPregel</h2></a>
	
	<p>jPregel is based on the paper 
		<a href="http://dl.acm.org/citation.cfm?id=1582723">"Pregel: a system for large-scale graph processing."</a>
		<!--
			by Grzegorz Malewicz, Matthew H. Austern, Aart J.C. Bik, James C. Dehnert, Ilan Horn, Naty Leiser, and 	Grzegorz Czajkowski 
			(all affiliated with Google, Inc.),
		Proceedings, PODC Proceedings of the 28th ACM symposium on Principles of Distributed Computing, 2009.
		-->
		</p>
		<p>
		jPregel's computational model consists of a directed graph (digraph) and may be described as vertex-centric:
		The graph's vertices are the active elements of a distributed graph algorithm.
		Every vertex is associated with the same <i>vertex algorithm</i>, encapsulated in its <i>compute</i> method.
		Attributes associated with each vertex include, but are not limited to:
		<ol>
			<li>a unique identifier</li>
			<li>a value</li>
			<li>a collection of out-edges, each of which has an associated value.</li>
		</ol>
		A <i>digraph algorithm</i> consists of a sequence of steps called <i>super steps</i>.
		Associated with each super step is a set of <i>active vertices</i>, each of which performs that super step.
		The set of active vertices that is associated with the initial super step is algorithmically defined by the process that constructs the initial graph.
		In subsequent super steps, a vertex is active if and only if the set of messages sent to it in the previous super step is non-empty.
		At each super step, each active vertex invokes its compute method, which may:
		<ul>
			<li>read messages sent to the vertex from vertices during the previous step;</li>
			<li>modify its state</li>
			<li>send messages to vertices (including itself), each of which is read by the receiving vertex during the next super step.</li>
		</ul> 
		If a super step has an empty set of active vertices, the digraph algorithm halts.
		(This termination condition of the distributed digraph algorithm is different from, but equivalent to, that of Pregel.)
		The following simple example gives the flavor of these concepts.
	</p>
	
	<h3>Example 1.1: Identifying a digraph's source nodes</h3>
	<p>
		At the time a digraph is constructed, a vertex, <i>v</i>, does not "know" if it has in-edges 
		(i.e., <i>v</i> does not "know" if there is a vertex <i>u</i> with an out-edge to <i>v</i>).
		Let us define a jpregel algorithm to determine if a vertex is a source (i.e., has no in-edges).
		We will illustrate our algorithm on the small digraph below:
	
		<center><img src="images/figures/Slide1.png" alt="a simple 7 node digraph with 2 source nodes." width="400"></center>
	</p>
	
	<h4>Algorithm</h4>
	<p>
		When the graph is constructed, all vertices are put in the active set and all vertices are initialized as a source.
		The graph algorithm has 2 super steps:
		<ol>
			<li>
				Each vertex <i>u</i> sends a message (which is empty) to vertex <i>v</i>, 
				if (<i>u</i>, <i>v</i>) is an out-edge of <i>u</i>.
			</li>
			<li>Active vertices mark themselves as not being a source.</li>
		</ol>
		Since no messages are sent during super step 2, the algorithm terminates after 2 super steps.
	</p>
		
	<h4>Correctness</h4>
	<p>
		After the graph algorithm terminates, 
		<i>vertex <i>v</i> is marked as not being a source</i> <br />
		if and only if <i>v</i> received at least one message at super step 2  <br />
		if and only if there is a vertex <i>u</i> with out-edge (<i>u</i>, <i>v</i>)  <br />
		if and only if <i>v</i> has in-edge (<i>u</i>, <i>v</i>)  <br />
		if and only if <i><i>v</i> is not a source</i>.
	</p>
	<p>
		After the graph computation terminates, there is an <i>output phase</i>.
		During the output phase of our source identification problem, each vertex outputs true, if it is a source, and false otherwise. 
	</p>
	
	<h4>Code</h4>
	<p>
		The following code fragment makes these ideas more precise, where the value associated with the vertex is a Boolean, 
		which, after the graph algorithm terminates, has a value of true if and only if the vertex is a source.
	</p>
	<style>
	<!--
	body {color: #000000; background-color: #ffffff; font-family: Monospaced}
	pre {color: #000000; background-color: #ffffff; font-family: Monospaced}
	table {color: #000000; background-color: #e9e8e2; font-family: Monospaced}
	.ST2 {font-family: Monospaced; font-style: italic}
	.ST1 {font-family: Monospaced; font-weight: bold}
	.ST0 {color: #969696; font-family: Monospaced; font-weight: bold}
	.comment {color: #969696}
	.character {color: #ce7b00}
	.keyword-directive {color: #0000e6}
	-->
	</style>
	
	<pre>
	    @Override
	    <span class="keyword-directive">public</span> <span class="keyword-directive">void</span> <span class="ST1">compute</span>() 
	    {
	        <span class="keyword-directive">if</span> ( <span class="keyword-directive">null</span> == getVertexValue() ) {
	            setVertexValue( <span class="keyword-directive">true</span> ); <span class="comment">// initially mark all vertices as sources</span>

	            <span class="comment">// for each out-edge (u, v), send a message to vertex v</span>
	            <span class="keyword-directive">for</span> ( Integer targetVertexId : getEdgeTargets() ) {
	                sendMessage( targetVertexId, <span class="keyword-directive">new</span> Message( <span class="keyword-directive">null</span>, <span class="keyword-directive">null</span> ) );
	            }
	        }
	        <span class="keyword-directive">else</span> <span class="keyword-directive">if</span> ( getMessageQ().size() &gt; 0 ) {
	                setVertexValue( <span class="keyword-directive">false</span> ); <span class="comment">// I have at least 1 in-edge!</span>
	        }
	    }

	    @Override
	    <span class="keyword-directive">public</span> String <span class="ST1">output</span>() { <span class="keyword-directive">return</span> getVertexId() + <span class="character">&quot;</span> <span class="character">&quot;</span> + getVertexValue(); }
	</pre>
	<p>
		Vertex methods <i>getVertexValue</i>, <i>setVertexValue</i>, <i>getEdgeTargets</i>, <i>sendMessage</i>, and <i>getMessageQ</i> 
		do what their names suggest.
		The full Vertex API is presented a bit later in the tutorial.
	</p>
	<p>
		Using the output from this jPregel application, if one were to paint the source vertices red and the non-source vertices blue, our small graph would, of course, look as follows:
		<center><img src="images/figures/Slide2.png" alt="a simple 7 node digraph with 2 source nodes." width="400"></center>
	</p>
	
	<p>
		In the chapters of this tutorial, you will learn how to develop jPregel applications, 
		how to deploy them, especially on AWS, which we have endeavored to make as easy as possible (we think you'll agree), 
		and how to contribute to this project.
	</p>
<!--
	
	<a name="Deploying-Applications"><h2>Deploying jPregel Applications</h2></a>
	<!--
	<h3>Deploying on a single machine</h3>
	
	<h3>Deploying on a local cluster</h3>
	
	<h3>Deploying on Amazon Web Services</h3>
	
	<ol>
		<li>Deploying with AWS
			<ol>
				<li>Setting up to deploy
					<ol>
						<li>Create an Amazon Web Services account. This requires a credit card.</li>
						<li>Create two SSH key pairs, named "privatekey" and "masterkey".</li>
						<li>Save these into privatekey.pem and masterkey.pem, in the jpregel-aws directory.</li>
						<li>Create a file named key.AWSkey, with your access key on the first line and your secret key on the second.</li>
					</ol>
				</li>
				<li>Deploying
					<ol>
						<li>From a Nebeans confirguration
							<ol>
								<li>
									<p>Specify a Main file with ant:</p>
									<p>ant run -propertyfile nbproject/configs/ShortestPath.properties -Dapplication.args="foobucket 10 10"</p>
								</li>
							</ol>
					</ol>
				</li>
			</ol>
		</li>
	</ol>
	
	
	<a name="Contributing-to-the-jpregel-project"><h2>Contributing to jPregel</h2></a>
-->
      </section>
      <footer>
        <p>Project maintained by <a href="https://github.com/charlesmunger">charlesmunger</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="http://twitter.com/#!/michigangraham">mattgraham</a></small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>